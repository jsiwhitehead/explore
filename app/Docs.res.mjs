// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import DataJson from "../data/data.json" with {"type": "json"};

var jsonDocs = DataJson;

var authors = [
  "The Báb",
  "Bahá’u’lláh",
  "‘Abdu’l‑Bahá",
  "Shoghi Effendi",
  "The Universal House of Justice",
  "The International Teaching Centre",
  "The World Centre",
  "Compilation",
  "The Ruhi Institute",
  "John E. Esslemont"
];

function unique(array) {
  return Array.from(new Set(array).values());
}

function decodeInt(json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (typeof json === "number") {
    if (Number.isInteger(json)) {
      return json | 0;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function decodeFloat(json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (typeof json === "number") {
    return json;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function decodeString(json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (typeof json === "string") {
    return json;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function decodeArray(json, decode) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (Array.isArray(json)) {
    return json.map(decode);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function decodeArraySafe(json, decode) {
  if (json !== undefined) {
    if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
      return [];
    } else if (Array.isArray(json)) {
      return json.map(decode);
    } else {
      return [];
    }
  } else {
    return [];
  }
}

function decodeDoc(json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (typeof json === "object" && !Array.isArray(json)) {
    var author = decodeString(Core__Option.getExn(json["author"], undefined));
    var path = decodeArray(Core__Option.getExn(json["path"], undefined), decodeString);
    var item = Core__Option.map(json["item"], decodeInt);
    var title = Core__Option.map(json["title"], decodeString);
    var match = Core__Option.getExn(json["years"], undefined);
    var tmp;
    if (!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean") {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (Array.isArray(match)) {
      if (match.length !== 2) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      var start = match[0];
      var end = match[1];
      tmp = [
        decodeFloat(start),
        decodeFloat(end)
      ];
    } else {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    return {
            id: decodeString(Core__Option.getExn(json["id"], undefined)),
            prayer: Caml_obj.equal(Core__Option.map(json["type"], decodeString), "Prayer"),
            author: author,
            path: path,
            item: item,
            title: title,
            breadcrumb: Core__Array.keepSome(Belt_Array.concatMany([
                      [[
                            "Commissioned by the Universal House of Justice",
                            "The Research Department",
                            "The Office of Social and Economic Development",
                            "Bahá’í International Community"
                          ].includes(author) ? "The World Centre" : author],
                      path.map(function (p) {
                            return p;
                          }),
                      [Core__Option.orElse(title, Core__Option.map(item, (function (item) {
                                    return item.toString();
                                  })))]
                    ])),
            years: tmp,
            source: Core__Option.map(json["source"], decodeString),
            paragraphs: decodeArray(Core__Option.getExn(json["paragraphs"], undefined), (function (x) {
                    return x;
                  }))
          };
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

var docsArray;

docsArray = !Array.isArray(jsonDocs) && (jsonDocs === null || typeof jsonDocs !== "object") && typeof jsonDocs !== "number" && typeof jsonDocs !== "string" && typeof jsonDocs !== "boolean" ? [] : (
    Array.isArray(jsonDocs) ? jsonDocs.map(decodeDoc) : []
  );

function decodeReference(json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (typeof json === "object" && !Array.isArray(json)) {
    return {
            doc: decodeInt(Core__Option.getExn(json["doc"], undefined)),
            paragraph: decodeInt(Core__Option.getExn(json["paragraph"], undefined)),
            start: decodeInt(Core__Option.getExn(json["start"], undefined)),
            end: decodeInt(Core__Option.getExn(json["end"], undefined))
          };
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function decodeParts(json) {
  return decodeArray(json, (function (item) {
                if (!Array.isArray(item) && (item === null || typeof item !== "object") && typeof item !== "number" && typeof item !== "string" && typeof item !== "boolean") {
                  throw {
                        RE_EXN_ID: "Not_found",
                        Error: new Error()
                      };
                }
                switch (typeof item) {
                  case "string" :
                      return {
                              TAG: "String",
                              _0: item
                            };
                  case "object" :
                      return {
                              TAG: "Quote",
                              _0: decodeReference(item)
                            };
                  default:
                    throw {
                          RE_EXN_ID: "Not_found",
                          Error: new Error()
                        };
                }
              }));
}

function decodeParagraph(json) {
  if (!Array.isArray(json) && (json === null || typeof json !== "object") && typeof json !== "number" && typeof json !== "string" && typeof json !== "boolean") {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  if (typeof json === "object" && !Array.isArray(json)) {
    var match = json["section"];
    var match$1 = json["quote"];
    var match$2 = json["type"];
    var match$3 = json["lines"];
    if (match !== undefined) {
      if (!Array.isArray(match) && (match === null || typeof match !== "object") && typeof match !== "number" && typeof match !== "string" && typeof match !== "boolean") {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      if (Array.isArray(match)) {
        if (match$1 !== undefined) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        if (match$2 !== undefined) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        if (match$3 !== undefined) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        var match$4 = json["title"];
        if (match$4 !== undefined && !(!Array.isArray(match$4) && (match$4 === null || typeof match$4 !== "object") && typeof match$4 !== "number" && typeof match$4 !== "string" && typeof match$4 !== "boolean" || typeof match$4 !== "string")) {
          return {
                  TAG: "Title",
                  _0: match.map(decodeInt),
                  _1: match$4
                };
        } else {
          return {
                  TAG: "Section",
                  _0: match.map(decodeInt)
                };
        }
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    } else if (match$1 !== undefined) {
      if (!Array.isArray(match$1) && (match$1 === null || typeof match$1 !== "object") && typeof match$1 !== "number" && typeof match$1 !== "string" && typeof match$1 !== "boolean") {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      if (typeof match$1 === "boolean") {
        if (match$1) {
          return {
                  TAG: "Quote",
                  _0: decodeParts(Core__Option.getExn(json["parts"], undefined))
                };
        }
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    } else if (match$2 !== undefined) {
      if (!Array.isArray(match$2) && (match$2 === null || typeof match$2 !== "object") && typeof match$2 !== "number" && typeof match$2 !== "string" && typeof match$2 !== "boolean") {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      if (typeof match$2 === "string") {
        switch (match$2) {
          case "call" :
              if (match$3 !== undefined) {
                throw {
                      RE_EXN_ID: "Not_found",
                      Error: new Error()
                    };
              }
              return {
                      TAG: "Call",
                      _0: decodeParts(Core__Option.getExn(json["parts"], undefined)),
                      _1: decodeArraySafe(json["citations"], decodeReference)
                    };
          case "info" :
              if (match$3 !== undefined) {
                throw {
                      RE_EXN_ID: "Not_found",
                      Error: new Error()
                    };
              }
              return {
                      TAG: "Info",
                      _0: decodeParts(Core__Option.getExn(json["parts"], undefined)),
                      _1: decodeArraySafe(json["citations"], decodeReference)
                    };
          default:
            throw {
                  RE_EXN_ID: "Not_found",
                  Error: new Error()
                };
        }
      } else {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
    } else {
      if (match$3 === undefined) {
        return {
                TAG: "Paragraph",
                _0: decodeInt(Core__Option.getExn(json["index"], undefined)),
                _1: decodeParts(Core__Option.getExn(json["parts"], undefined)),
                _2: decodeArraySafe(json["citations"], decodeReference)
              };
      }
      if (!Array.isArray(match$3) && (match$3 === null || typeof match$3 !== "object") && typeof match$3 !== "number" && typeof match$3 !== "string" && typeof match$3 !== "boolean") {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      if (Array.isArray(match$3)) {
        return {
                TAG: "Lines",
                _0: match$3.map(decodeInt),
                _1: decodeParts(Core__Option.getExn(json["parts"], undefined)),
                _2: decodeArraySafe(json["citations"], decodeReference)
              };
      }
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
  } else {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
}

function partsToText(parts) {
  return parts.map(function (part) {
                if (part.TAG === "String") {
                  return part._0;
                } else {
                  return getReference(part._0);
                }
              }).join("");
}

function paragraphToText(paragraph) {
  switch (paragraph.TAG) {
    case "Section" :
        return "* * *";
    case "Title" :
        return paragraph._1;
    case "Lines" :
    case "Paragraph" :
        return partsToText(paragraph._1);
    default:
      return partsToText(paragraph._0);
  }
}

function getReference(reference) {
  return paragraphToText(decodeParagraph(docsArray[reference.doc].paragraphs[reference.paragraph])).slice(reference.start, reference.end);
}

function paragraphToRender(paragraph) {
  switch (paragraph.TAG) {
    case "Section" :
        return [
                "section",
                ["* * *"],
                0
              ];
    case "Title" :
        return [
                "title",
                [paragraph._1],
                paragraph._0.length
              ];
    case "Quote" :
        return [
                "quote",
                [partsToText(paragraph._0)],
                0
              ];
    case "Info" :
        return [
                "info",
                [partsToText(paragraph._0)],
                0
              ];
    case "Call" :
        return [
                "call",
                [partsToText(paragraph._0)],
                0
              ];
    case "Lines" :
        var lines = paragraph._0;
        var text = partsToText(paragraph._1);
        return [
                "lines",
                lines.slice(1).map(function (param, i) {
                      return text.slice(lines[i], lines[i + 1 | 0]);
                    }),
                0
              ];
    case "Paragraph" :
        return [
                paragraph._0 === 1 ? "first" : "",
                [partsToText(paragraph._1)],
                0
              ];
    
  }
}

function getParagraphs(selected) {
  if (selected.length > 0) {
    return Core__Option.map(docsArray.find(function (doc) {
                    return Caml_obj.equal(doc.breadcrumb, selected);
                  }), (function (doc) {
                  return doc.paragraphs.map(function (json) {
                              return paragraphToRender(decodeParagraph(json));
                            });
                }));
  }
  
}

function getList(selected) {
  if (selected.length === 0) {
    return authors;
  }
  var array = Core__Array.filterMap(docsArray.filter(function (doc) {
            if (doc.prayer) {
              return false;
            } else {
              return Caml_obj.equal(doc.breadcrumb.slice(0, selected.length), selected);
            }
          }), (function (doc) {
          return doc.breadcrumb[selected.length];
        }));
  return Array.from(new Set(array).values());
}

export {
  jsonDocs ,
  authors ,
  unique ,
  decodeInt ,
  decodeFloat ,
  decodeString ,
  decodeArray ,
  decodeArraySafe ,
  decodeDoc ,
  docsArray ,
  decodeReference ,
  decodeParts ,
  decodeParagraph ,
  partsToText ,
  paragraphToText ,
  getReference ,
  paragraphToRender ,
  getParagraphs ,
  getList ,
}
/* jsonDocs Not a pure module */
