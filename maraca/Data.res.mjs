// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__Dict from "@rescript/core/src/Core__Dict.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as SignalsMjs from "./Signals.mjs";

function atomBase(prim0, prim1) {
  return SignalsMjs.signal(prim0, prim1);
}

function computedBase(prim0, prim1) {
  return SignalsMjs.computed(prim0, prim1);
}

function effect(prim) {
  SignalsMjs.effect(prim);
}

function effectWithCleanup(prim) {
  return SignalsMjs.effect(prim);
}

function batch(prim) {
  SignalsMjs.batch(prim);
}

function untracked(prim) {
  return SignalsMjs.untracked(prim);
}

function atom(initial, isEqual) {
  var base = SignalsMjs.signal(initial, isEqual);
  return [
          (function () {
              return base.value;
            }),
          (function (value) {
              base.value = value;
            })
        ];
}

function computed(func, isEqual) {
  var base = SignalsMjs.computed(func, isEqual);
  return function () {
    return base.value;
  };
}

function setToOption(set) {
  if (typeof set !== "object") {
    return ;
  } else {
    return Caml_option.some(set._0);
  }
}

function optionToSet(option) {
  if (option !== undefined) {
    return {
            TAG: "Single",
            _0: Caml_option.valFromOption(option)
          };
  } else {
    return "Empty";
  }
}

function setToArray(set) {
  if (typeof set !== "object") {
    return [];
  } else if (set.TAG === "Single") {
    return [set._0];
  } else {
    return Belt_Array.concatMany([
                [set._0],
                set._1
              ]);
  }
}

function arrayToSet(array) {
  var match = array[0];
  var match$1 = array.slice(1);
  if (match === undefined) {
    return "Empty";
  }
  var value = Caml_option.valFromOption(match);
  if (match$1.length !== 0) {
    return {
            TAG: "Multi",
            _0: value,
            _1: match$1
          };
  } else {
    return {
            TAG: "Single",
            _0: value
          };
  }
}

function dataToBool(data) {
  if (data !== undefined && !(typeof data === "object" && data.NAME === "Bool" && !data.VAL)) {
    return true;
  } else {
    return false;
  }
}

function dataEqual(a, b) {
  if (a !== undefined && b !== undefined && !(typeof a === "object" && a.NAME === "Block" && typeof b === "object" && b.NAME === "Block")) {
    return Caml_obj.equal(a, b);
  } else {
    return false;
  }
}

function valueEqual(a, b) {
  if (typeof a !== "object") {
    if (typeof b !== "object") {
      return true;
    } else {
      return false;
    }
  }
  if (a.TAG !== "Single") {
    return false;
  }
  var a$1 = a._0;
  if (a$1.TAG !== "Data") {
    return false;
  }
  if (typeof b !== "object") {
    return false;
  }
  if (b.TAG !== "Single") {
    return false;
  }
  var b$1 = b._0;
  if (b$1.TAG === "Data") {
    return dataEqual(a$1._0, b$1._0);
  } else {
    return false;
  }
}

function atomValue(initial) {
  return atom(initial, valueEqual);
}

function computedValue(func) {
  return computed(func, valueEqual);
}

function get(signal) {
  if (signal.TAG === "Atom") {
    return signal._0[0]();
  } else {
    return signal._0();
  }
}

function dataToAtoms(data) {
  var variant = data.NAME;
  var tmp;
  if (variant === "Block") {
    var match = data.VAL;
    tmp = {
      NAME: "Block",
      VAL: [
        Core__Dict.mapValues(match[0], (function (data) {
                return {
                        TAG: "Single",
                        _0: dataToAtoms(data)
                      };
              })),
        match[1].map(function (data) {
              return {
                      TAG: "Single",
                      _0: dataToAtoms(data)
                    };
            })
      ]
    };
  } else {
    tmp = variant === "Float" ? ({
          NAME: "Float",
          VAL: data.VAL
        }) : (
        variant === "Bool" ? ({
              NAME: "Bool",
              VAL: data.VAL
            }) : ({
              NAME: "String",
              VAL: data.VAL
            })
      );
  }
  return {
          TAG: "Signal",
          _0: {
            TAG: "Atom",
            _0: atom({
                  TAG: "Single",
                  _0: {
                    TAG: "Data",
                    _0: tmp
                  }
                }, valueEqual)
          }
        };
}

function dataToSignalData(data) {
  var variant = data.NAME;
  var tmp;
  if (variant === "Block") {
    var match = data.VAL;
    tmp = {
      NAME: "Block",
      VAL: [
        Core__Dict.mapValues(match[0], (function (data) {
                return {
                        TAG: "Single",
                        _0: dataToAtoms(data)
                      };
              })),
        match[1].map(function (data) {
              return {
                      TAG: "Single",
                      _0: dataToAtoms(data)
                    };
            })
      ]
    };
  } else {
    tmp = variant === "Float" ? ({
          NAME: "Float",
          VAL: data.VAL
        }) : (
        variant === "Bool" ? ({
              NAME: "Bool",
              VAL: data.VAL
            }) : ({
              NAME: "String",
              VAL: data.VAL
            })
      );
  }
  return {
          TAG: "Data",
          _0: tmp
        };
}

export {
  atomBase ,
  computedBase ,
  effect ,
  effectWithCleanup ,
  batch ,
  untracked ,
  atom ,
  computed ,
  setToOption ,
  optionToSet ,
  setToArray ,
  arrayToSet ,
  dataToBool ,
  dataEqual ,
  valueEqual ,
  atomValue ,
  computedValue ,
  get ,
  dataToAtoms ,
  dataToSignalData ,
}
/* ./Signals.mjs Not a pure module */
