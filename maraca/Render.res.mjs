// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Data from "./Data.res.mjs";
import * as Resolve from "./Resolve.res.mjs";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Float from "@rescript/core/src/Core__Float.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function dictMap(dict, map) {
  return Object.fromEntries(Object.entries(dict).map(function (param) {
                  var k = param[0];
                  return [
                          k,
                          map(k, param[1])
                        ];
                }));
}

function dictKeepSome(dict) {
  return Object.fromEntries(Core__Array.filterMap(Object.entries(dict), (function (param) {
                    var k = param[0];
                    return Core__Option.map(param[1], (function (x) {
                                  return [
                                          k,
                                          x
                                        ];
                                }));
                  })));
}

function resolveValueKeyed(value, key) {
  return Data.setToArray(value).flatMap(function (data, index) {
              var newKey = key + "." + index.toString();
              if (data.TAG === "Data") {
                return [[
                          newKey,
                          data._0
                        ]];
              } else {
                return resolveValueKeyed(Data.get(data._0), newKey);
              }
            });
}

function resolveItemsKeyed(items) {
  return items.flatMap(function (data, index) {
              return resolveValueKeyed(data, index.toString());
            });
}

var createNode = ((key, nodeType) => {
  let res;
  if (nodeType === "Text") {
    res = document.createTextNode("");
  } else if (nodeType === "Input") {
    res = document.createElement("div");
    res.replaceChildren(document.createElement("input"));
  } else if (nodeType === "Wrap") {
    res = document.createElement("div");
    res.replaceChildren(document.createElement("div"));
  } else if (nodeType === "Block") {
    res = document.createElement("div");
  }
  res.__type = nodeType;
  res.__key = key;
  return res;
});

var childNodesKeyed = ((node) => {
  const inner = ["Input", "Wrap"].includes(node.__type) ? node.childNodes[0] : node;
  return [...inner.childNodes].reduce((res, c) => ({ ...res, [c.__key]: c }), {});
});

var updateTextNode = ((node, text) => {
  node.textContent = text.normalize("NFD").replace(/\u0323/g, "").normalize("NFC");
});

var updateNodeProps = ((node, props, style) => {
  const focusNode = node.__type === "Input" ? node.childNodes[0] : node;
  for (const key in props) {
    if (key === "focus") {
      if (props[key]) setTimeout(() => focusNode.focus());
    } else if (["onfocus", "onblur", "value" , "oninput"].includes(key)) {
      focusNode[key] = props[key] ?? null;
    } else {
      node[key] = props[key] ?? null;
    }
  }
  if (node.__type === "Input") node.childNodes[0].readOnly = !props.oninput;
  const marginNode = ["Input", "Wrap"].includes(node.__type) ? node.childNodes[0] : node;
  for (const key in style) {
    if (["marginTop", "marginBottom", "minHeight"].includes(key)) {
      marginNode.style[key] = style[key] ?? null;
    } else {
      node.style[key] = style[key] ?? null;
    }
  }
});

var updateChildren = ((node, nextChildren) => {
  const inner = ["Input", "Wrap"].includes(node.__type) ? node.childNodes[0] : node;
  const prevChildren = Array.from(inner.childNodes);
  const prevMap = prevChildren.reduce((res, c) => ({ ...res, [c.__key]: true }), {});
  const nextMap = nextChildren.reduce((res, c) => ({ ...res, [c.__key]: true }), {});
  prevChildren.forEach(prev => {
    if (!nextMap[prev.__key]) inner.removeChild(prev);
  });
  nextChildren.forEach((next, i) => {
    if (!prevMap[next.__key]) {
      const after = nextChildren.slice(i).find(c => prevMap[c.__key]);
      if (after) inner.insertBefore(after, next);
      else inner.appendChild(next);
    }
  });
});

function getNextNode(key, prevNode, nextType) {
  return Core__Option.getOr(Core__Option.flatMap(prevNode, (function (n) {
                    if (n.__type === nextType) {
                      return Caml_option.some(n);
                    }
                    
                  })), createNode(key, nextType));
}

var atomKeys = [
  "hover",
  "click",
  "focus",
  "key",
  "input"
];

function resolveToRenderData(items) {
  return resolveItemsKeyed(items).map(function (param) {
              var data = param[1];
              var variant = data.NAME;
              var tmp;
              if (variant === "Block") {
                var match = data.VAL;
                tmp = {
                  TAG: "Block",
                  _0: match[0],
                  _1: match[1]
                };
              } else {
                tmp = variant === "Float" ? ({
                      TAG: "String",
                      _0: data.VAL.toString()
                    }) : (
                    variant === "Bool" ? ({
                          TAG: "String",
                          _0: data.VAL ? "Yes" : "No"
                        }) : (
                        variant === "Func" ? ({
                              TAG: "String",
                              _0: "<< Function >>"
                            }) : ({
                              TAG: "String",
                              _0: data.VAL
                            })
                      )
                  );
              }
              return [
                      param[0],
                      tmp
                    ];
            });
}

function getBool(values, key) {
  return Core__Option.flatMap(values[key], (function (data) {
                if (typeof data !== "object") {
                  return ;
                }
                var variant = data.NAME;
                if (variant === "String") {
                  return data.VAL !== "";
                } else if (variant === "Bool") {
                  return data.VAL;
                } else {
                  return ;
                }
              }));
}

function getFloat(values, key) {
  return Core__Option.flatMap(values[key], (function (data) {
                if (typeof data !== "object") {
                  return ;
                }
                var variant = data.NAME;
                if (variant === "String") {
                  return Core__Float.fromString(data.VAL);
                } else if (variant === "Float") {
                  return data.VAL;
                } else {
                  return ;
                }
              }));
}

function getString(values, key) {
  return Core__Option.flatMap(values[key], (function (data) {
                if (typeof data === "object" && data.NAME === "String") {
                  return Caml_option.some(data.VAL);
                }
                
              }));
}

function getStringFloat(values, key) {
  return Core__Option.flatMap(values[key], (function (data) {
                if (typeof data !== "object") {
                  return ;
                }
                var variant = data.NAME;
                if (variant === "String") {
                  return data.VAL;
                } else if (variant === "Float") {
                  return data.VAL.toString();
                } else {
                  return ;
                }
              }));
}

function getItems(flow, gap, items) {
  if (Caml_obj.notequal(Core__Option.getOr(flow, {
              NAME: "String",
              VAL: "inline"
            }), {
          NAME: "String",
          VAL: "inline"
        }) || gap !== undefined) {
    return items.map(function (param) {
                var item = param[1];
                var tmp;
                tmp = item.TAG === "String" ? ({
                      TAG: "Block",
                      _0: {},
                      _1: [{
                          TAG: "Single",
                          _0: {
                            TAG: "Data",
                            _0: {
                              NAME: "String",
                              VAL: item._0
                            }
                          }
                        }]
                    }) : item;
                return [
                        param[0],
                        tmp
                      ];
              });
  } else {
    return items;
  }
}

function getInline(prevInline, flow, items) {
  if (prevInline === "inline" || prevInline === "wrap") {
    return "inline";
  } else if (Caml_obj.equal(flow, {
          NAME: "String",
          VAL: "inline"
        }) || items.some(function (param) {
          return param[1].TAG === "String" ? true : false;
        })) {
    return "wrap";
  } else {
    return "none";
  }
}

function getContext(prevContext, values, items) {
  var match = prevContext.inline;
  return {
          size: Core__Option.getOr(getFloat(values, "size"), prevContext.size),
          line: Core__Option.getOr(getFloat(values, "line"), prevContext.line),
          inline: match === "inline" || match === "wrap" ? "inline" : (
              Caml_obj.equal(getString(values, "flow"), "inline") || items.some(function (param) {
                    if (param[1].TAG === "String") {
                      return true;
                    } else {
                      return false;
                    }
                  }) ? "wrap" : "none"
            )
        };
}

function valuesToProps(values, atoms) {
  return {
          onmouseover: Core__Option.map(atoms["hover"], (function (hover) {
                  return function (param) {
                    hover({
                          TAG: "Single",
                          _0: {
                            TAG: "Data",
                            _0: {
                              NAME: "Bool",
                              VAL: true
                            }
                          }
                        });
                  };
                })),
          onmouseleave: Core__Option.map(atoms["hover"], (function (hover) {
                  return function (param) {
                    hover("Empty");
                  };
                })),
          onclick: Core__Option.map(atoms["click"], (function (click) {
                  return function ($$event) {
                    click({
                          TAG: "Single",
                          _0: {
                            TAG: "Data",
                            _0: {
                              NAME: "Block",
                              VAL: [
                                {},
                                []
                              ]
                            }
                          }
                        });
                    $$event.stopPropagation();
                  };
                })),
          onfocus: Core__Option.map(atoms["focus"], (function (focus) {
                  return function (param) {
                    focus({
                          TAG: "Single",
                          _0: {
                            TAG: "Data",
                            _0: {
                              NAME: "Bool",
                              VAL: true
                            }
                          }
                        });
                  };
                })),
          onblur: Core__Option.map(atoms["focus"], (function (focus) {
                  return function (param) {
                    focus("Empty");
                  };
                })),
          focus: Core__Option.getOr(getBool(values, "isFocus"), false),
          onkeydown: Core__Option.map(atoms["key"], (function (key) {
                  return function ($$event) {
                    key({
                          TAG: "Single",
                          _0: {
                            TAG: "Data",
                            _0: {
                              NAME: "Block",
                              VAL: [
                                {
                                  key: {
                                    TAG: "Single",
                                    _0: {
                                      TAG: "Data",
                                      _0: {
                                        NAME: "String",
                                        VAL: $$event.key
                                      }
                                    }
                                  }
                                },
                                []
                              ]
                            }
                          }
                        });
                    $$event.stopPropagation();
                  };
                })),
          value: getStringFloat(values, "input"),
          oninput: Core__Option.map(atoms["input"], (function (input) {
                  return function ($$event) {
                    input({
                          TAG: "Single",
                          _0: {
                            TAG: "Data",
                            _0: {
                              NAME: "String",
                              VAL: $$event.target.value
                            }
                          }
                        });
                  };
                }))
        };
}

function blockToDirections(values, items) {
  return [
          Core__Option.orElse(values["top"], Core__Option.orElse(items[0], undefined)),
          Core__Option.orElse(values["right"], Core__Option.orElse(items[3], Core__Option.orElse(items[1], Core__Option.orElse(items[0], undefined)))),
          Core__Option.orElse(values["bottom"], Core__Option.orElse(items[2], Core__Option.orElse(items[0], undefined))),
          Core__Option.orElse(values["left"], Core__Option.orElse(items[1], Core__Option.orElse(items[0], undefined)))
        ];
}

function valuesToStyle(values, atoms, context) {
  var match = Core__Option.mapOr(getString(values, "align"), [
        "inherit",
        "inherit"
      ], (function (align) {
          if (align.includes("justify")) {
            return [
                    "justify",
                    align.slice(8)
                  ];
          } else {
            return [
                    align,
                    "none"
                  ];
          }
        }));
  var lineGap = (context.line - 1) * context.size / 2;
  var isInput = Core__Option.isSome(values["input"]);
  var borderDirections = Core__Option.mapOr(values["border"], undefined, (function (v) {
          if (typeof v !== "object") {
            return ;
          }
          var variant = v.NAME;
          if (variant === "String") {
            var string = v.VAL;
            return [
                    string,
                    string,
                    string,
                    string
                  ];
          }
          if (variant !== "Block") {
            return ;
          }
          var match = v.VAL;
          return blockToDirections(match[0], match[1]).map(function (v) {
                      if (v !== undefined && typeof v === "object" && v.NAME === "String") {
                        return v.VAL;
                      } else {
                        return "none";
                      }
                    });
        }));
  var match$1 = context.inline;
  return {
          display: match$1 === "wrap" ? "block" : (
              match$1 === "inline" ? "inline" : "flex"
            ),
          flexDirection: context.inline === "none" ? Core__Option.getOr(getString(values, "flow"), "column") : "",
          width: Core__Option.getOr(getString(values, "width"), context.inline === "none" ? "100%" : ""),
          marginTop: context.inline === "wrap" || isInput ? "-" + lineGap.toString() + "px" : "",
          marginBottom: context.inline === "wrap" || isInput ? "-" + lineGap.toString() + "px" : "",
          marginLeft: Core__Option.isSome(values["maxWidth"]) ? "auto" : "0",
          marginRight: Core__Option.isSome(values["maxWidth"]) ? "auto" : "0",
          height: Core__Option.getOr(getString(values, "height"), "auto"),
          minHeight: Core__Option.getOr(getString(values, "minHeight"), context.inline === "wrap" || isInput ? (context.line * context.size).toString() + "px" : ""),
          maxWidth: Core__Option.mapOr(getFloat(values, "maxWidth"), "auto", (function (v) {
                  return v.toString() + "px";
                })),
          gap: Core__Option.getOr(getFloat(values, "gap"), 0).toString() + "px",
          fontFamily: Core__Option.getOr(getString(values, "font"), "inherit"),
          fontSize: context.size.toString() + "px",
          lineHeight: context.line.toString(),
          fontWeight: Core__Option.mapOr(getBool(values, "bold"), "inherit", (function (v) {
                  if (v) {
                    return "bold";
                  } else {
                    return "normal";
                  }
                })),
          fontStyle: Core__Option.mapOr(getBool(values, "italic"), "inherit", (function (v) {
                  if (v) {
                    return "italic";
                  } else {
                    return "normal";
                  }
                })),
          textDecoration: Core__Option.mapOr(getBool(values, "underline"), "inherit", (function (v) {
                  if (v) {
                    return "underline";
                  } else {
                    return "inherit";
                  }
                })),
          textTransform: Core__Option.mapOr(getBool(values, "uppercase"), "inherit", (function (v) {
                  if (v) {
                    return "uppercase";
                  } else {
                    return "inherit";
                  }
                })),
          textAlign: match[0],
          textAlignLast: match[1],
          textIndent: Core__Option.mapOr(getFloat(values, "indent"), "inherit", (function (v) {
                  return v.toString() + "px";
                })),
          whiteSpace: Core__Option.getOr(getString(values, "whitespace"), "inherit"),
          color: Core__Option.getOr(getString(values, "color"), "inherit"),
          padding: Core__Option.mapOr(values["pad"], "", (function (v) {
                  if (typeof v !== "object") {
                    return "";
                  }
                  var variant = v.NAME;
                  if (variant === "String") {
                    return v.VAL + "px";
                  }
                  if (variant !== "Block") {
                    if (variant === "Float") {
                      return v.VAL.toString() + "px";
                    } else {
                      return "";
                    }
                  }
                  var match = v.VAL;
                  return blockToDirections(match[0], match[1]).map(function (v) {
                                if (v === undefined) {
                                  return "0px";
                                }
                                if (typeof v !== "object") {
                                  return "0px";
                                }
                                var variant = v.NAME;
                                if (variant === "String") {
                                  return v.VAL + "px";
                                } else if (variant === "Float") {
                                  return v.VAL.toString() + "px";
                                } else {
                                  return "0px";
                                }
                              }).join(" ");
                })),
          background: Core__Option.getOr(getString(values, "fill"), ""),
          borderTop: Core__Option.getOr(Core__Option.flatMap(borderDirections, (function (v) {
                      return v[0];
                    })), "none"),
          borderLeft: Core__Option.getOr(Core__Option.flatMap(borderDirections, (function (v) {
                      return v[1];
                    })), "none"),
          borderBottom: Core__Option.getOr(Core__Option.flatMap(borderDirections, (function (v) {
                      return v[2];
                    })), "none"),
          borderRight: Core__Option.getOr(Core__Option.flatMap(borderDirections, (function (v) {
                      return v[3];
                    })), "none"),
          cursor: Core__Option.isSome(atoms["click"]) ? "pointer" : "normal"
        };
}

function updateNode(key, node, data, context) {
  if (data.TAG === "String") {
    var res = getNextNode(key, node, "Text");
    updateTextNode(res, data._0);
    return [
            res,
            (function () {
                
              })
          ];
  }
  var values = data._0;
  var isInput = Core__Option.isSome(Core__Option.flatMap(values["input"], Resolve.resolveValueAtom));
  var flow = Core__Option.flatMap(values["flow"], Resolve.resolveDeepValueOption);
  var gap = Core__Option.flatMap(values["gap"], Resolve.resolveDeepValueOption);
  var renderItems = getItems(flow, gap, resolveToRenderData(isInput ? [] : data._1));
  var nextInline = getInline(context.inline, flow, renderItems);
  var res$1 = getNextNode(key, node, isInput ? "Input" : (
          nextInline === "wrap" ? "Wrap" : "Block"
        ));
  var cleanup = Data.effectWithCleanup(function () {
        var atoms = dictKeepSome(dictMap(values, (function (key, value) {
                    if (atomKeys.includes(key)) {
                      return Resolve.resolveValueAtom(value);
                    }
                    
                  })));
        var resValues = dictKeepSome(dictMap(values, (function (key, value) {
                    if (!atomKeys.includes(key) || key === "input") {
                      return Resolve.resolveDeepValueOption(value);
                    }
                    
                  })));
        var nextContext = getContext(context, resValues, renderItems);
        updateNodeProps(res$1, valuesToProps(resValues, atoms), valuesToStyle(resValues, atoms, nextContext));
        if (isInput) {
          return function () {
            
          };
        } else {
          return Data.effectWithCleanup(function () {
                      return updateItems(res$1, renderItems, nextContext);
                    });
        }
      });
  return [
          res$1,
          cleanup
        ];
}

function updateItems(node, items, context) {
  var keyed = childNodesKeyed(node);
  var pairs = items.map(function (param) {
        var k = param[0];
        return updateNode(k, keyed[k], param[1], context);
      });
  updateChildren(node, pairs.map(function (param) {
            return param[0];
          }));
  return function () {
    pairs.forEach(function (param) {
          param[1]();
        });
  };
}

var root = document.getElementById("app");

function render(value) {
  return Data.effectWithCleanup(function () {
              return updateItems(root, resolveToRenderData([value]), {
                          size: 16,
                          line: 1.5,
                          inline: "none"
                        });
            });
}

export {
  dictMap ,
  dictKeepSome ,
  resolveValueKeyed ,
  resolveItemsKeyed ,
  createNode ,
  childNodesKeyed ,
  updateTextNode ,
  updateNodeProps ,
  updateChildren ,
  getNextNode ,
  atomKeys ,
  resolveToRenderData ,
  getBool ,
  getFloat ,
  getString ,
  getStringFloat ,
  getItems ,
  getInline ,
  getContext ,
  valuesToProps ,
  blockToDirections ,
  valuesToStyle ,
  updateNode ,
  updateItems ,
  root ,
  render ,
}
/* root Not a pure module */
