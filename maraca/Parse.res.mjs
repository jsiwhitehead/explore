// Generated by ReScript, PLEASE EDIT WITH CARE

import * as OhmJs from "ohm-js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var grammar = OhmJs.grammar("Script {\n\n  start\n    = space* (s_value | chunk)* space*\n\n  value\n    = ternary\n\n  ternary\n    = or space* \"?\" space* or space* \":\" space* ternary -- ternary\n    | or\n\n  or\n    = or space* \"|\" space* and -- or\n    | and\n\n  and\n    = and space* \"&\" space* equal -- and\n    | equal\n\n  equal\n    = equal space* (\"!=\" | \"=\") space* compare -- equal\n    | compare\n\n  compare\n    = compare space* (\"<=\" | \">=\" | \"<\" | \">\") space* sum -- compare\n    | sum\n\n  sum\n    = sum space* (\"+\" | \"-\") space+ product -- sum\n    | product\n\n  product\n    = product space* (\"*\" | \"/\" | \"%\") space* power -- product\n    | power\n\n  power\n    = power space* \"^\" space* unary -- power\n    | unary\n\n  unary\n    = (\"-\" | \"!\") space* unary -- unary\n    | \"...\" space* unary -- unpack\n    | apply\n\n  apply\n    = apply \".\" label -- key\n    | apply \"[\" space* value space* \"]\" -- get\n    | apply \"(\" space* items space* \")\" -- call\n    | atom\n\n  items\n    = listOf<value, separator> space* \",\"?\n\n  atom\n    = string | number | boolean | label | brackets\n\n  chunk\n    = (char | escape)+\n\n  char\n    = ~(\"\\\\\" | \"{\") any\n\n  string\n    = \"'\" (s_value | s_chunk)* \"'\"\n\n  s_value\n    = \"{\" space* value space* \"}\"\n\n  s_chunk\n    = (s_char | escape)+\n\n  s_char\n    = ~(\"'\" | \"\\\\\" | \"{\") any\n\n  escape\n    = \"\\\\\" any\n\n  number\n    = digit+ (\".\" digit+)?\n\n  boolean\n    = (\"yes\" | \"no\") ~alnum\n\n  label\n    = alnum+\n\n  brackets\n    = \"(\" space* value space* \")\"\n\n  separator\n    = space* \",\" space*\n    | (linespace* \"\\n\")+ linespace*\n\n  linespace\n    = ~\"\\n\" \"\\x00\"..\"\\x20\"\n\n}");

var semantics = grammar.createSemantics();

function binary(a, param, b, param$1, c) {
  return {
          NAME: "Operation",
          VAL: [
            b.sourceString,
            [
              a.ast,
              c.ast
            ]
          ]
        };
}

semantics.addAttribute("ast", {
      start: (function (param, a, param$1) {
          if (a.ast.length > 1) {
            return {
                    NAME: "Operation",
                    VAL: [
                      "_",
                      a.ast
                    ]
                  };
          }
          var x = a.ast[0];
          if (x !== undefined) {
            return Caml_option.valFromOption(x);
          } else {
            return {
                    NAME: "String",
                    VAL: ""
                  };
          }
        }),
      ternary_ternary: (function (a, param, param$1, param$2, b, param$3, param$4, param$5, c) {
          return {
                  NAME: "Operation",
                  VAL: [
                    "?",
                    [
                      a.ast,
                      b.ast,
                      c.ast
                    ]
                  ]
                };
        }),
      or_or: binary,
      and_and: binary,
      equal_equal: binary,
      compare_compare: binary,
      sum_sum: binary,
      product_product: binary,
      power_power: binary,
      unary_unary: (function (a, param, b) {
          return {
                  NAME: "Operation",
                  VAL: [
                    a.sourceString,
                    [b.ast]
                  ]
                };
        }),
      unary_unpack: (function (param, param$1, a) {
          return {
                  NAME: "Unpack",
                  VAL: a.ast
                };
        }),
      apply_key: (function (a, param, b) {
          return {
                  NAME: "Get",
                  VAL: [
                    a.ast,
                    {
                      NAME: "String",
                      VAL: b.sourceString
                    }
                  ]
                };
        }),
      apply_get: (function (a, param, param$1, b, param$2, param$3) {
          return {
                  NAME: "Get",
                  VAL: [
                    a.ast,
                    b.ast
                  ]
                };
        }),
      apply_call: (function (a, param, param$1, b, param$2, param$3) {
          return {
                  NAME: "Call",
                  VAL: [
                    a.ast,
                    b.ast
                  ]
                };
        }),
      items: (function (a, param, param$1) {
          return a.ast;
        }),
      chunk: (function (a) {
          return {
                  NAME: "String",
                  VAL: a.sourceString.replace(/\\(.)/g, "$1")
                };
        }),
      string: (function (param, a, param$1) {
          if (a.ast.length > 1) {
            return {
                    NAME: "Operation",
                    VAL: [
                      "_",
                      a.ast
                    ]
                  };
          }
          var x = a.ast[0];
          if (x !== undefined) {
            return Caml_option.valFromOption(x);
          } else {
            return {
                    NAME: "String",
                    VAL: ""
                  };
          }
        }),
      s_value: (function (param, param$1, a, param$2, param$3) {
          return a.ast;
        }),
      s_chunk: (function (a) {
          return {
                  NAME: "String",
                  VAL: a.sourceString.replace(/\\(.)/g, "$1")
                };
        }),
      number: (function (a, b, c) {
          return {
                  NAME: "Float",
                  VAL: parseFloat(a.sourceString + b.sourceString + c.sourceString)
                };
        }),
      boolean: (function (a) {
          return {
                  NAME: "Bool",
                  VAL: a.sourceString === "yes"
                };
        }),
      label: (function (a) {
          return {
                  NAME: "Label",
                  VAL: a.sourceString
                };
        }),
      brackets: (function (param, param$1, a, param$2, param$3) {
          return a.ast;
        }),
      nonemptyListOf: (function (a, param, b) {
          return Belt_Array.concatMany([
                      [a.ast],
                      b.ast
                    ]);
        }),
      _iter: ((...children) => children.map((c) => c.ast)),
      _terminal: (function () {
          
        })
    });

var Parse_Failed = /* @__PURE__ */Caml_exceptions.create("Parse.Parse_Failed");

function parse(script) {
  var m = grammar.match(script);
  if (m.succeeded()) {
    return (semantics(m).ast);
  }
  console.log(m.message);
  throw {
        RE_EXN_ID: Parse_Failed,
        Error: new Error()
      };
}

export {
  grammar ,
  semantics ,
  binary ,
  Parse_Failed ,
  parse ,
}
/* grammar Not a pure module */
